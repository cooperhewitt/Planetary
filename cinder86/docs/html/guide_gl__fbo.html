<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Cinder: Guide to Framebuffer Objects (FBOs)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cinder_extra_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.libcinder.org"><img alt="Logo" src="logo.png"/></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cinder
   &#160;<span id="projectnumber">0.8.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Guide to Framebuffer Objects (FBOs) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>In OpenGL, the results of rendering commands end up as pixels in a 2D image called a <em>framebuffer</em>. The default framebuffer in OpenGL is automatically drawn to the screen, but Framebuffer Objects (FBOs) provide a mechanism for users to supply an alternative, off-screen destination. Drawing off-screen enables a number of effects which are difficult or impossible otherwise. For example, imagine you want to blur the entire screen. By using an FBO, you can capture the result of your rendering commands before they hit the screen, process those pixels using an OpenGL shader, and then draw the blurred pixels instead of the originals.<br />
<br />
</p>
<p>A framebuffer can also encapsulate more than just red-green-blue data per pixel. In fact by default OpenGL stores depth information, as well as alpha (or coverage) values, among other things. An FBO can also represent this additional information, allowing the storage and processing of alpha and depth information. Furthermore, all of this information can be used as textures in subsequent OpenGL rendering. This technique is often called <em>render-to-texture</em>.</p>
<p><br />
 </p><h2>Setting up an FBO</h2>
<p>To setup an FBO, the first step is to specify the size of the FBO in pixels.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_fbo_8h.html">cinder/gl/Fbo.h</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>ci;</div>
<div class="line">gl::Fbo myFbo( 640, 480 );</div>
</div><!-- fragment --><p> <br />
 Because we have not specified any formatting parameters, the FBO defaults to a format that emulates the normal screen-based framebuffer, storing RGB as well as alpha and depth information. To make use of the FBO, the first step is to bind it as the current framebuffer. </p><div class="fragment"><div class="line">myFbo.bindFramebuffer();</div>
<div class="line">&lt;...drawing commands...&gt;</div>
</div><!-- fragment --><p> <br />
 Now any rendering commands we issue will render to our FBO instead of the screen. Once we are finished rendering off-screen, we will want to restore the screen as the primary framebuffer, which we'll do like this: </p><div class="fragment"><div class="line">myFbo.unbindFramebuffer();</div>
</div><!-- fragment --><p> <br />
 At this point, our FBO contains the result of our rendering commands stored as a <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a>. We can do any number of things with these pixels. Assuming we have a shader which blurs, we might do something like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_glsl_prog_8h.html">cinder/gl/GlslProg.h</a>&quot;</span></div>
<div class="line">gl::GlslProg blurShader;</div>
<div class="line">blurShader.uniform( <span class="stringliteral">&quot;blurRadius&quot;</span>, 5.0<a class="code" href="_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a> );</div>
<div class="line">blurShader.bind();</div>
<div class="line"><a class="code" href="_g_lee_8h.html#a3ae8bf9d2f2d075f326e6ed513ca2fcb">gl::draw</a>( myFbo.getTexture() ); <span class="comment">// draw the contents of the Fbo by using it as a texture</span></div>
<div class="line">blurShader.unbind();</div>
</div><!-- fragment --><h2><br />
Advanced Formats</h2>
<p>The Cinder FBO class also support customizing what data is stored in the FBO using the <a class="el" href="structcinder_1_1gl_1_1_fbo_1_1_format.html">Fbo::Format</a> object. For example to enable mip-mapping, you would write something about like this: </p><div class="fragment"><div class="line">gl::Fbo::Format <a class="code" href="_g_lee_8h.html#a86f086d889f7cdb4d6461497ae891265">format</a>;</div>
<div class="line">format.enableMipmapping();</div>
<div class="line">gl::Fbo myFbo( 640, 480, format );</div>
</div><!-- fragment --><p> <br />
 The <a class="el" href="structcinder_1_1gl_1_1_fbo_1_1_format.html">Fbo::Format</a> object can also be used to modify the way the data of the framebuffer is stored. For example, on implementations that support it, we can enable a high dynamic range floating point framebuffer by passing the constant <code>GL_RGBA32F</code> as the format for storing the color data, meaning 32-bit floating point data for red, green, blue and alpha.</p>
<div class="fragment"><div class="line">gl::Fbo::Format hdrFormat;</div>
<div class="line">hdrFormat.setColorInternalFormat( <a class="code" href="_g_lee_8h.html#ace8155682f86789a9af13e7026df4615">GL_RGBA32F</a> );</div>
<div class="line">gl::Fbo myHdrFbo( 640, 480, hdrFormat );</div>
</div><!-- fragment --><h2><br />
Antialiasing with FBOs</h2>
<p>The Cinder ci::gl::Fbo also supports the option to antialias FBOs on implementations that support it. The typical technique is known as <em>multisample antialiasing</em> (MSAA), and works simply by taking several samples per pixel and averaging them together. This averaging step must be performed after all the rendering has taken place, and the Cinder FBO class automatically takes care of it when you call <a class="el" href="classcinder_1_1gl_1_1_fbo.html#a3e2201cbdfb0227e0cf98ab17a559488">Fbo::getTexture()</a> or <a class="el" href="classcinder_1_1gl_1_1_fbo.html#a8c8e2e75815c7e4354e22102ec1aaa0d">Fbo::bindTexture()</a>. <br />
<br />
 In order to enable MSAA, set your format to use a value greater than 1 for its samples. </p><div class="fragment"><div class="line">gl::Fbo::Format msaaFormat;</div>
<div class="line">msaaFormat.setSamples( 4 ); <span class="comment">// enable 4x MSAA</span></div>
<div class="line">gl::Fbo myMsaaFbo( 640, 480, msaaFormat );</div>
</div><!-- fragment --><p> <br />
 Additionally, though currently limited to Nvidia cards on Windows, the Cinder FBO supports an antialiasing scheme known as <em>coverage sample antialiasing</em> (CSAA). This technique works by determining pixel coverage information (effectively alpha) in a less expensive manner than MSAA. Per Nvidia's documentation, "...CSAA produces antialiased images that rival the quality of 8x or 16x MSAA, while introducing only a minimal performance hit over standard (typically 4x) MSAA." To understand more about how CSAA works, <a href="http://developer.nvidia.com/object/coverage-sampled-aa.html">please refer to this documentation from Nvidia</a>. This feature can be enabled in Cinder's <a class="el" href="classcinder_1_1gl_1_1_fbo.html">gl::Fbo</a> class like so: </p><div class="fragment"><div class="line">gl::Fbo::Format csaaFormat;</div>
<div class="line">csaaFormat.setSamples( 4 );</div>
<div class="line">csaaFormat.setCoverageSamples( 8 ); <span class="comment">// a combination which creates the &quot;CSAA 8x&quot; mode</span></div>
<div class="line">gl::Fbo myCsaaFbo( 640, 480, csaaFormat );</div>
</div><!-- fragment --><p> <br />
 </p><dl class="section note"><dt>Note</dt><dd>Currenty by enabling FBO multisampling, you automatically disable the depth buffer's availablility as a texture, though your FBO may still contain a depth buffer. Consequently <a class="el" href="classcinder_1_1gl_1_1_fbo.html#a956919b4e2f86735543b3c289dfb9437">getDepthTexture()</a> and <a class="el" href="classcinder_1_1gl_1_1_fbo.html#a0ef31243c7db0488658bfc8d562d9bd4">bindDepthTexture()</a> will fail. <br />
 <h2>Saving FBO Contents</h2>
</dd></dl>
<p>Saving the pixels from an FBO is quite straightforward. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_image_io_8h.html">cinder/ImageIo.h</a>&quot;</span></div>
<div class="line"><a class="code" href="namespacecinder.html#ae77edb896e2f8e90bba70000725f3b6e">writeImage</a>( <a class="code" href="namespacecinder.html#a2b598230b99b65cfa51a92eace60abc0">getHomeDirectory</a>() + <span class="stringliteral">&quot;myPixels.png&quot;</span>, myFbo.getTexture() );</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
