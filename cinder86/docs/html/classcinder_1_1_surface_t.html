<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Cinder: cinder::SurfaceT&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cinder_extra_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.libcinder.org"><img alt="Logo" src="logo.png"/></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cinder
   &#160;<span id="projectnumber">0.8.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecinder.html">cinder</a></li><li class="navelem"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcinder_1_1_surface_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cinder::SurfaceT&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An in-memory representation of an image. <a class="el" href="guide__impl_shared.html">Implicitly shared object</a>.  
 <a href="classcinder_1_1_surface_t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_surface_8h_source.html">Surface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for iterating the pixels of a Surface. The iteration is <code>const</code>, performing read-only operations on the Surface.  <a href="classcinder_1_1_surface_t_1_1_const_iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for iterating the pixels of a Surface.  <a href="classcinder_1_1_surface_t_1_1_iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a785e8c6fabbdbaeb65712e4858833479"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a785e8c6fabbdbaeb65712e4858833479">SurfaceT</a> ()</td></tr>
<tr class="memdesc:a785e8c6fabbdbaeb65712e4858833479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty Surface, which is the equivalent of NULL and should not be used directly.  <a href="#a785e8c6fabbdbaeb65712e4858833479">More...</a><br /></td></tr>
<tr class="separator:a785e8c6fabbdbaeb65712e4858833479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bcd91acdf1111d5da624a21e67f99a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a34bcd91acdf1111d5da624a21e67f99a">SurfaceT</a> (int32_t <a class="el" href="_g_lee_8h.html#ac112eef468530a44b7a653ddac190a22">width</a>, int32_t <a class="el" href="_g_lee_8h.html#ab375df5e95c5fc63fc9165319162bddc">height</a>, bool <a class="el" href="_g_lee_8h.html#a55d98ec4b6aa35ace9b91275e7ad847b">alpha</a>, <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> channelOrder=<a class="el" href="classcinder_1_1_surface_channel_order.html#aaff3651ad59ef9ac3239a7ef7796f18ca5ab01894183ce51b9c6ef707828fdd4f">SurfaceChannelOrder::UNSPECIFIED</a>)</td></tr>
<tr class="memdesc:a34bcd91acdf1111d5da624a21e67f99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Surface object that is <em>height</em> and <em>width</em> pixels, an alpha channel based on <em>alpha</em>, and the channel order <em>channelOrder</em>.  <a href="#a34bcd91acdf1111d5da624a21e67f99a">More...</a><br /></td></tr>
<tr class="separator:a34bcd91acdf1111d5da624a21e67f99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8eb913b83effb58ee15badd198dcd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a7f8eb913b83effb58ee15badd198dcd0">SurfaceT</a> (int32_t <a class="el" href="_g_lee_8h.html#ac112eef468530a44b7a653ddac190a22">width</a>, int32_t <a class="el" href="_g_lee_8h.html#ab375df5e95c5fc63fc9165319162bddc">height</a>, bool <a class="el" href="_g_lee_8h.html#a55d98ec4b6aa35ace9b91275e7ad847b">alpha</a>, const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;constraints)</td></tr>
<tr class="separator:a7f8eb913b83effb58ee15badd198dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9004fd8b1e0c500e02fcdfbdbe571ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ac9004fd8b1e0c500e02fcdfbdbe571ed">SurfaceT</a> (T *<a class="el" href="_g_lee_8h.html#a8850df0785e6fbcc2351af3b686b8c7a">data</a>, int32_t <a class="el" href="_g_lee_8h.html#ac112eef468530a44b7a653ddac190a22">width</a>, int32_t <a class="el" href="_g_lee_8h.html#ab375df5e95c5fc63fc9165319162bddc">height</a>, int32_t rowBytes, <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> channelOrder)</td></tr>
<tr class="memdesc:ac9004fd8b1e0c500e02fcdfbdbe571ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a surface from the memory pointed to by <em>data</em>. Does not assume ownership of the memory in <em>data</em>, which consequently should not be freed while the Surface is still in use.  <a href="#ac9004fd8b1e0c500e02fcdfbdbe571ed">More...</a><br /></td></tr>
<tr class="separator:ac9004fd8b1e0c500e02fcdfbdbe571ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e994d9c8a799dd4a4540d6650f7ecb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a55e994d9c8a799dd4a4540d6650f7ecb">SurfaceT</a> (<a class="el" href="namespacecinder.html#aca11590d504e68de86f3a57444c2eb70">ImageSourceRef</a> imageSource, const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;constraints=<a class="el" href="classcinder_1_1_surface_constraints_default.html">SurfaceConstraintsDefault</a>(), boost::tribool <a class="el" href="_g_lee_8h.html#a55d98ec4b6aa35ace9b91275e7ad847b">alpha</a>=boost::logic::indeterminate)</td></tr>
<tr class="memdesc:a55e994d9c8a799dd4a4540d6650f7ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Surface object from an <a class="el" href="classcinder_1_1_image_source.html">ImageSource</a>, for instance from the result of a <a class="el" href="namespacecinder.html#ad49aa427548e365f95336af782c2161a" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a> call.  <a href="#a55e994d9c8a799dd4a4540d6650f7ecb">More...</a><br /></td></tr>
<tr class="separator:a55e994d9c8a799dd4a4540d6650f7ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79defcf8e73b0526f26af3be914f78be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a79defcf8e73b0526f26af3be914f78be">operator ImageSourceRef</a> () const </td></tr>
<tr class="separator:a79defcf8e73b0526f26af3be914f78be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a1e5d14987a74b858969eb5ee81c42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a32a1e5d14987a74b858969eb5ee81c42">operator ImageTargetRef</a> ()</td></tr>
<tr class="separator:a32a1e5d14987a74b858969eb5ee81c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8928d870737daf9f59fdfb83fa51e4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a1b8928d870737daf9f59fdfb83fa51e4">getWidth</a> () const </td></tr>
<tr class="memdesc:a1b8928d870737daf9f59fdfb83fa51e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the Surface in pixels.  <a href="#a1b8928d870737daf9f59fdfb83fa51e4">More...</a><br /></td></tr>
<tr class="separator:a1b8928d870737daf9f59fdfb83fa51e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb727cb106dc1b4b537991ccd1a218d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#abbb727cb106dc1b4b537991ccd1a218d">getHeight</a> () const </td></tr>
<tr class="memdesc:abbb727cb106dc1b4b537991ccd1a218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height of the Surface in pixels.  <a href="#abbb727cb106dc1b4b537991ccd1a218d">More...</a><br /></td></tr>
<tr class="separator:abbb727cb106dc1b4b537991ccd1a218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240bf5253a4cfffa06a4ea6e07002331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a240bf5253a4cfffa06a4ea6e07002331">getSize</a> () const </td></tr>
<tr class="memdesc:a240bf5253a4cfffa06a4ea6e07002331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the Surface in pixels.  <a href="#a240bf5253a4cfffa06a4ea6e07002331">More...</a><br /></td></tr>
<tr class="separator:a240bf5253a4cfffa06a4ea6e07002331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24266e8d1474dc9f817183745c844791"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a24266e8d1474dc9f817183745c844791">getAspectRatio</a> () const </td></tr>
<tr class="memdesc:a24266e8d1474dc9f817183745c844791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Surface aspect ratio, which is its width / height.  <a href="#a24266e8d1474dc9f817183745c844791">More...</a><br /></td></tr>
<tr class="separator:a24266e8d1474dc9f817183745c844791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c7c63efe35fc8c4c97531b4d20884e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_area.html">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ab5c7c63efe35fc8c4c97531b4d20884e">getBounds</a> () const </td></tr>
<tr class="memdesc:ab5c7c63efe35fc8c4c97531b4d20884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding <a class="el" href="classcinder_1_1_area.html">Area</a> of the Surface in pixels: [0,0]-(width,height)  <a href="#ab5c7c63efe35fc8c4c97531b4d20884e">More...</a><br /></td></tr>
<tr class="separator:ab5c7c63efe35fc8c4c97531b4d20884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82124f1cf056043b85248eacf472e225"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a82124f1cf056043b85248eacf472e225">hasAlpha</a> () const </td></tr>
<tr class="memdesc:a82124f1cf056043b85248eacf472e225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Surface contains an alpha channel.  <a href="#a82124f1cf056043b85248eacf472e225">More...</a><br /></td></tr>
<tr class="separator:a82124f1cf056043b85248eacf472e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e75b813f8af6255e3de692086abdd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a73e75b813f8af6255e3de692086abdd7">isPremultiplied</a> () const </td></tr>
<tr class="memdesc:a73e75b813f8af6255e3de692086abdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Surface color data is premultiplied by its alpha channel or not.  <a href="#a73e75b813f8af6255e3de692086abdd7">More...</a><br /></td></tr>
<tr class="separator:a73e75b813f8af6255e3de692086abdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf7e047bb742b97186cfca3a131cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af3cf7e047bb742b97186cfca3a131cb3">setPremultiplied</a> (bool premult=true) const </td></tr>
<tr class="memdesc:af3cf7e047bb742b97186cfca3a131cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the Surface color data should be interpreted as being premultiplied by its alpha channel or not.  <a href="#af3cf7e047bb742b97186cfca3a131cb3">More...</a><br /></td></tr>
<tr class="separator:af3cf7e047bb742b97186cfca3a131cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a5f9c0c1768c751f3096d1fe83ab11"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a81a5f9c0c1768c751f3096d1fe83ab11">getRowBytes</a> () const </td></tr>
<tr class="memdesc:a81a5f9c0c1768c751f3096d1fe83ab11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of a row of the Surface measured in bytes, which is not necessarily <a class="el" href="classcinder_1_1_surface_t.html#a1b8928d870737daf9f59fdfb83fa51e4" title="Returns the width of the Surface in pixels. ">getWidth()</a> * <a class="el" href="classcinder_1_1_surface_t.html#a550c975403a6f65c15348a6c87ac338b" title="Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels...">getPixelInc()</a>  <a href="#a81a5f9c0c1768c751f3096d1fe83ab11">More...</a><br /></td></tr>
<tr class="separator:a81a5f9c0c1768c751f3096d1fe83ab11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550c975403a6f65c15348a6c87ac338b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a550c975403a6f65c15348a6c87ac338b">getPixelInc</a> () const </td></tr>
<tr class="memdesc:a550c975403a6f65c15348a6c87ac338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels, which is either 3 or 4.  <a href="#a550c975403a6f65c15348a6c87ac338b">More...</a><br /></td></tr>
<tr class="separator:a550c975403a6f65c15348a6c87ac338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d86f9b1875c30ac38dfb6447245049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a29d86f9b1875c30ac38dfb6447245049">clone</a> (bool copyPixels=true) const </td></tr>
<tr class="memdesc:a29d86f9b1875c30ac38dfb6447245049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new Surface which is a duplicate. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized.  <a href="#a29d86f9b1875c30ac38dfb6447245049">More...</a><br /></td></tr>
<tr class="separator:a29d86f9b1875c30ac38dfb6447245049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2e20f388b53fb6868c5ba393f0ecfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a1c2e20f388b53fb6868c5ba393f0ecfe">clone</a> (const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;area, bool copyPixels=true) const </td></tr>
<tr class="memdesc:a1c2e20f388b53fb6868c5ba393f0ecfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new Surface which is a duplicate of an <a class="el" href="classcinder_1_1_area.html">Area</a> <em>area</em>. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized.  <a href="#a1c2e20f388b53fb6868c5ba393f0ecfe">More...</a><br /></td></tr>
<tr class="separator:a1c2e20f388b53fb6868c5ba393f0ecfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dd5a31c22eab567c6d6be938518cd6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a87dd5a31c22eab567c6d6be938518cd6">getData</a> ()</td></tr>
<tr class="memdesc:a87dd5a31c22eab567c6d6be938518cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns the raw data of an image as a pointer to either uin8t_t values in the case of a Surface8u or floats in the case of a Surface32f.  <a href="#a87dd5a31c22eab567c6d6be938518cd6">More...</a><br /></td></tr>
<tr class="separator:a87dd5a31c22eab567c6d6be938518cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91cd98ff60c2a42f80c6e35fdbf9840"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ab91cd98ff60c2a42f80c6e35fdbf9840">getData</a> () const </td></tr>
<tr class="separator:ab91cd98ff60c2a42f80c6e35fdbf9840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42de94fd28f7d2cd9466a3e5818cb97b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a42de94fd28f7d2cd9466a3e5818cb97b">getData</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>)</td></tr>
<tr class="separator:a42de94fd28f7d2cd9466a3e5818cb97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36448ec39df80e5479cbc19a9b39d10d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a36448ec39df80e5479cbc19a9b39d10d">getData</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>) const </td></tr>
<tr class="separator:a36448ec39df80e5479cbc19a9b39d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb65f9b84984d2401784d0eeb49a016"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#aecb65f9b84984d2401784d0eeb49a016">getDataRed</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>)</td></tr>
<tr class="memdesc:aecb65f9b84984d2401784d0eeb49a016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the red channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f.  <a href="#aecb65f9b84984d2401784d0eeb49a016">More...</a><br /></td></tr>
<tr class="separator:aecb65f9b84984d2401784d0eeb49a016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c2e4bc4a0716733baa09cd71d98688"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a71c2e4bc4a0716733baa09cd71d98688">getDataRed</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>) const </td></tr>
<tr class="separator:a71c2e4bc4a0716733baa09cd71d98688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06838ab7980d61a3e38c7d81c70cb1a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af06838ab7980d61a3e38c7d81c70cb1a">getDataGreen</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>)</td></tr>
<tr class="memdesc:af06838ab7980d61a3e38c7d81c70cb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the green channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f.  <a href="#af06838ab7980d61a3e38c7d81c70cb1a">More...</a><br /></td></tr>
<tr class="separator:af06838ab7980d61a3e38c7d81c70cb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca0ac9cef34420506c50b0a4721187e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a6ca0ac9cef34420506c50b0a4721187e">getDataGreen</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>) const </td></tr>
<tr class="separator:a6ca0ac9cef34420506c50b0a4721187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc96e9623b2cf02a2b6e271dd39de862"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#abc96e9623b2cf02a2b6e271dd39de862">getDataBlue</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>)</td></tr>
<tr class="memdesc:abc96e9623b2cf02a2b6e271dd39de862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the blue channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f.  <a href="#abc96e9623b2cf02a2b6e271dd39de862">More...</a><br /></td></tr>
<tr class="separator:abc96e9623b2cf02a2b6e271dd39de862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60614c57a4e35717999c322e562a8777"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a60614c57a4e35717999c322e562a8777">getDataBlue</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>) const </td></tr>
<tr class="separator:a60614c57a4e35717999c322e562a8777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add41dcdc946d694e77a205a3f655d40d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#add41dcdc946d694e77a205a3f655d40d">getDataAlpha</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>)</td></tr>
<tr class="memdesc:add41dcdc946d694e77a205a3f655d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the alpha channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. Undefined for Surfaces without an alpha channel.  <a href="#add41dcdc946d694e77a205a3f655d40d">More...</a><br /></td></tr>
<tr class="separator:add41dcdc946d694e77a205a3f655d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40094fa0fa5d0448c41fbaabb67ba15"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ac40094fa0fa5d0448c41fbaabb67ba15">getDataAlpha</a> (const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;<a class="el" href="_g_lee_8h.html#ae1b92ae085ddef4b1cdca7d749339fb0">offset</a>) const </td></tr>
<tr class="separator:ac40094fa0fa5d0448c41fbaabb67ba15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1252ffdf7852caccfd03b23df157467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ae1252ffdf7852caccfd03b23df157467">setDeallocator</a> (<a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>(*aDeallocatorFunc)(<a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> *), <a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> *aDeallocatorRefcon)</td></tr>
<tr class="separator:ae1252ffdf7852caccfd03b23df157467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c7558fadb5a922d1d086c884bd10c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af12c7558fadb5a922d1d086c884bd10c">getChannelOrder</a> () const </td></tr>
<tr class="memdesc:af12c7558fadb5a922d1d086c884bd10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the channel order of the Surface, the in-memory ordering of the channels of each pixel.  <a href="#af12c7558fadb5a922d1d086c884bd10c">More...</a><br /></td></tr>
<tr class="separator:af12c7558fadb5a922d1d086c884bd10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e1f09b8d4d98fad12977d4fffb0cf7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a93e1f09b8d4d98fad12977d4fffb0cf7">getRedOffset</a> () const </td></tr>
<tr class="memdesc:a93e1f09b8d4d98fad12977d4fffb0cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 0.  <a href="#a93e1f09b8d4d98fad12977d4fffb0cf7">More...</a><br /></td></tr>
<tr class="separator:a93e1f09b8d4d98fad12977d4fffb0cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c390c3d39809c34fcbc653788d0b1e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a2c390c3d39809c34fcbc653788d0b1e8">getGreenOffset</a> () const </td></tr>
<tr class="memdesc:a2c390c3d39809c34fcbc653788d0b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 1.  <a href="#a2c390c3d39809c34fcbc653788d0b1e8">More...</a><br /></td></tr>
<tr class="separator:a2c390c3d39809c34fcbc653788d0b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ef6f9eaf2d5ea76a850497842a21a3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a95ef6f9eaf2d5ea76a850497842a21a3">getBlueOffset</a> () const </td></tr>
<tr class="memdesc:a95ef6f9eaf2d5ea76a850497842a21a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 2.  <a href="#a95ef6f9eaf2d5ea76a850497842a21a3">More...</a><br /></td></tr>
<tr class="separator:a95ef6f9eaf2d5ea76a850497842a21a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072f2b80c7aca558f6cdb0997c1797a8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a072f2b80c7aca558f6cdb0997c1797a8">getAlphaOffset</a> () const </td></tr>
<tr class="memdesc:a072f2b80c7aca558f6cdb0997c1797a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 3. Returns <a class="el" href="classcinder_1_1_surface_channel_order.html#a9c1f57f5975fdae6bd51fa5f31ec4301ae72ecc43e9d7c20bfeb89665268eaa3c">SurfaceChannelOrder::INVALID</a> in the absence of an alpha channel.  <a href="#a072f2b80c7aca558f6cdb0997c1797a8">More...</a><br /></td></tr>
<tr class="separator:a072f2b80c7aca558f6cdb0997c1797a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf07eae37706817ca0885d306b5cd0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#aaf07eae37706817ca0885d306b5cd0e1">setChannelOrder</a> (const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> &amp;aChannelOrder)</td></tr>
<tr class="memdesc:aaf07eae37706817ca0885d306b5cd0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the channel order of the Surface, the in-memory ordering of the channels of each pixel. Call does not modify any pixel data, but does modify its interpretation.  <a href="#aaf07eae37706817ca0885d306b5cd0e1">More...</a><br /></td></tr>
<tr class="separator:aaf07eae37706817ca0885d306b5cd0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e3a626f08cc734005b91ad63eed1f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ae9e3a626f08cc734005b91ad63eed1f0">getChannel</a> (uint8_t channelIndex)</td></tr>
<tr class="memdesc:ae9e3a626f08cc734005b91ad63eed1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface. ">SurfaceChannelOrder</a>.  <a href="#ae9e3a626f08cc734005b91ad63eed1f0">More...</a><br /></td></tr>
<tr class="separator:ae9e3a626f08cc734005b91ad63eed1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e5e6da1ae553cae5d1485c2e66237a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#aa7e5e6da1ae553cae5d1485c2e66237a">getChannel</a> (uint8_t channelIndex) const </td></tr>
<tr class="memdesc:aa7e5e6da1ae553cae5d1485c2e66237a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface. ">SurfaceChannelOrder</a>.  <a href="#aa7e5e6da1ae553cae5d1485c2e66237a">More...</a><br /></td></tr>
<tr class="separator:aa7e5e6da1ae553cae5d1485c2e66237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18dfcdd556a475d3141cdba45602eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ad18dfcdd556a475d3141cdba45602eec">getChannelRed</a> ()</td></tr>
<tr class="memdesc:ad18dfcdd556a475d3141cdba45602eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the red Channel of the Surface.  <a href="#ad18dfcdd556a475d3141cdba45602eec">More...</a><br /></td></tr>
<tr class="separator:ad18dfcdd556a475d3141cdba45602eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958b48daeefd05e0ff2c7c33e9c21aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a958b48daeefd05e0ff2c7c33e9c21aca">getChannelGreen</a> ()</td></tr>
<tr class="memdesc:a958b48daeefd05e0ff2c7c33e9c21aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the green Channel of the Surface.  <a href="#a958b48daeefd05e0ff2c7c33e9c21aca">More...</a><br /></td></tr>
<tr class="separator:a958b48daeefd05e0ff2c7c33e9c21aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36bbf0e559edbca50c03e4d44790ae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ae36bbf0e559edbca50c03e4d44790ae0">getChannelBlue</a> ()</td></tr>
<tr class="memdesc:ae36bbf0e559edbca50c03e4d44790ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the blue Channel of the Surface.  <a href="#ae36bbf0e559edbca50c03e4d44790ae0">More...</a><br /></td></tr>
<tr class="separator:ae36bbf0e559edbca50c03e4d44790ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822adcec9d90e990d7a4d8d6b79d8485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a822adcec9d90e990d7a4d8d6b79d8485">getChannelAlpha</a> ()</td></tr>
<tr class="memdesc:a822adcec9d90e990d7a4d8d6b79d8485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the alpha Channel of the Surface.  <a href="#a822adcec9d90e990d7a4d8d6b79d8485">More...</a><br /></td></tr>
<tr class="separator:a822adcec9d90e990d7a4d8d6b79d8485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91d2903ff37e2b85ccd8786c6483d15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af91d2903ff37e2b85ccd8786c6483d15">getChannelRed</a> () const </td></tr>
<tr class="memdesc:af91d2903ff37e2b85ccd8786c6483d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the red Channel of the Surface.  <a href="#af91d2903ff37e2b85ccd8786c6483d15">More...</a><br /></td></tr>
<tr class="separator:af91d2903ff37e2b85ccd8786c6483d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a64d6c6418df75127d5f585a9b9e2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a64a64d6c6418df75127d5f585a9b9e2f">getChannelGreen</a> () const </td></tr>
<tr class="memdesc:a64a64d6c6418df75127d5f585a9b9e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the green Channel of the Surface.  <a href="#a64a64d6c6418df75127d5f585a9b9e2f">More...</a><br /></td></tr>
<tr class="separator:a64a64d6c6418df75127d5f585a9b9e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498f923a3235754d916b07ac3b9ca938"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a498f923a3235754d916b07ac3b9ca938">getChannelBlue</a> () const </td></tr>
<tr class="memdesc:a498f923a3235754d916b07ac3b9ca938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the blue Channel of the Surface.  <a href="#a498f923a3235754d916b07ac3b9ca938">More...</a><br /></td></tr>
<tr class="separator:a498f923a3235754d916b07ac3b9ca938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab432240ffbc3c0c5906e25d4ea96f674"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ab432240ffbc3c0c5906e25d4ea96f674">getChannelAlpha</a> () const </td></tr>
<tr class="memdesc:ab432240ffbc3c0c5906e25d4ea96f674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the alpha Channel of the Surface.  <a href="#ab432240ffbc3c0c5906e25d4ea96f674">More...</a><br /></td></tr>
<tr class="separator:ab432240ffbc3c0c5906e25d4ea96f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862e892ced2cea8d422683ab82915012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a862e892ced2cea8d422683ab82915012">getPixel</a> (<a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> pos) const </td></tr>
<tr class="memdesc:a862e892ced2cea8d422683ab82915012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for getting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead.  <a href="#a862e892ced2cea8d422683ab82915012">More...</a><br /></td></tr>
<tr class="separator:a862e892ced2cea8d422683ab82915012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeef32100150e5748551c074b433f6ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#abeef32100150e5748551c074b433f6ab">setPixel</a> (<a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> pos, const <a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt; &amp;<a class="el" href="_g_lee_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a>)</td></tr>
<tr class="memdesc:abeef32100150e5748551c074b433f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead.  <a href="#abeef32100150e5748551c074b433f6ab">More...</a><br /></td></tr>
<tr class="separator:abeef32100150e5748551c074b433f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b0c7a1d4ef7e749ec068df95fd9b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a65b0c7a1d4ef7e749ec068df95fd9b42">setPixel</a> (<a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> pos, const <a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt; T &gt; &amp;<a class="el" href="_g_lee_8h.html#a1f2d7f8147412c43ba2303a56f97ee73">c</a>)</td></tr>
<tr class="memdesc:a65b0c7a1d4ef7e749ec068df95fd9b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead.  <a href="#a65b0c7a1d4ef7e749ec068df95fd9b42">More...</a><br /></td></tr>
<tr class="separator:a65b0c7a1d4ef7e749ec068df95fd9b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dda39e47f015905cc43471e7e426d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a73dda39e47f015905cc43471e7e426d3">copyFrom</a> (const <a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; &amp;srcSurface, const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;srcArea, const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;relativeOffset=<a class="el" href="classcinder_1_1_vec2.html#ab746e54851a2dec15ba2d547909efe59">Vec2i::zero</a>())</td></tr>
<tr class="memdesc:a73dda39e47f015905cc43471e7e426d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <a class="el" href="classcinder_1_1_area.html">Area</a> <em>srcArea</em> of the Surface <em>srcSurface</em> to <em>this</em> Surface. The destination <a class="el" href="classcinder_1_1_area.html">Area</a> is <em>srcArea</em> offset by <em>relativeOffset</em>.  <a href="#a73dda39e47f015905cc43471e7e426d3">More...</a><br /></td></tr>
<tr class="separator:a73dda39e47f015905cc43471e7e426d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c5d89e1bcdf1c0e70d36adc6bb6bc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a11c5d89e1bcdf1c0e70d36adc6bb6bc6">areaAverage</a> (const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;area) const </td></tr>
<tr class="memdesc:a11c5d89e1bcdf1c0e70d36adc6bb6bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an averaged color for the <a class="el" href="classcinder_1_1_area.html">Area</a> defined by <em>area</em>.  <a href="#a11c5d89e1bcdf1c0e70d36adc6bb6bc6">More...</a><br /></td></tr>
<tr class="separator:a11c5d89e1bcdf1c0e70d36adc6bb6bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d33a9fdbb5242e13e27c0dfc7fe7c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a2d33a9fdbb5242e13e27c0dfc7fe7c33">getIter</a> ()</td></tr>
<tr class="memdesc:a2d33a9fdbb5242e13e27c0dfc7fe7c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface. ">Iter</a> which iterates the entire Surface.  <a href="#a2d33a9fdbb5242e13e27c0dfc7fe7c33">More...</a><br /></td></tr>
<tr class="separator:a2d33a9fdbb5242e13e27c0dfc7fe7c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed96afb9b9a7deb59e48e694dc2d3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a8ed96afb9b9a7deb59e48e694dc2d3b1">getIter</a> (const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;area)</td></tr>
<tr class="memdesc:a8ed96afb9b9a7deb59e48e694dc2d3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface. ">Iter</a> which iterates the <a class="el" href="classcinder_1_1_area.html">Area</a> <em>area</em>.  <a href="#a8ed96afb9b9a7deb59e48e694dc2d3b1">More...</a><br /></td></tr>
<tr class="separator:a8ed96afb9b9a7deb59e48e694dc2d3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3c36d49617eb6c833177e1dc940cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a9e3c36d49617eb6c833177e1dc940cce">getIter</a> () const </td></tr>
<tr class="memdesc:a9e3c36d49617eb6c833177e1dc940cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the entire Surface.  <a href="#a9e3c36d49617eb6c833177e1dc940cce">More...</a><br /></td></tr>
<tr class="separator:a9e3c36d49617eb6c833177e1dc940cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf005ed5921c23587fcdc470a9fe063b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#adf005ed5921c23587fcdc470a9fe063b">getIter</a> (const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;area) const </td></tr>
<tr class="memdesc:adf005ed5921c23587fcdc470a9fe063b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the <a class="el" href="classcinder_1_1_area.html">Area</a> <em>area</em>.  <a href="#adf005ed5921c23587fcdc470a9fe063b">More...</a><br /></td></tr>
<tr class="separator:adf005ed5921c23587fcdc470a9fe063b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class cinder::SurfaceT&lt; T &gt;</h3>

<p>An in-memory representation of an image. <a class="el" href="guide__impl_shared.html">Implicitly shared object</a>. </p>
<p>A Surface always contains red, green and blue data, along with an optional alpha channel.<br />
 <br />
 Surfaces come in two primary configurations, the traditional 8-bits per channel represented by <a class="el" href="namespacecinder.html#ad8b046fa928d58861b60465ceda392c5">Surface8u</a>, and a float per channel, suitable for high dynamic range images, represented by <a class="el" href="namespacecinder.html#a69465422e6011583c33994f0280dcd29">Surface32f</a>. <em>Surface</em> is a short-hand synonym for <em>Surface8u</em>. <br />
 <br />
 Surfaces are a CPU-based image representation, and must be converted appropriately to be drawn using the GPU. For example, to be used with OpenGL, the <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a> is a natural choice, and it can be constructed directly from a Surface.<br />
 <br />
 To manipulate individual pixels of a Surface, the <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> class can be used.<br />
 <br />
 To allocate a Surface that is 640x480 and has an alpha channel, use:<br />
 <code>Surface mySurface( 640, 480, true );</code><br />
 A Surface can be created from an image file using the result of <a class="el" href="namespacecinder.html#ad49aa427548e365f95336af782c2161a" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a>:<br />
 <code>Surface bitmap( loadImage( "image.jpg" ) );</code><br />
 <br />
 The pixels of each row of a Surface are stored in contiguous memory, and the start of each row is offset from the previous by the stride (measured in bytes) returned by <a class="el" href="classcinder_1_1_surface_t.html#a81a5f9c0c1768c751f3096d1fe83ab11">getRowBytes()</a>. Pixels can be ordered in memory in a number of configurations, specified using the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface. ">SurfaceChannelOrder</a> class. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="guide__images.html">Images in Cinder</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a785e8c6fabbdbaeb65712e4858833479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an empty Surface, which is the equivalent of NULL and should not be used directly. </p>

</div>
</div>
<a class="anchor" id="a34bcd91acdf1111d5da624a21e67f99a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a>&#160;</td>
          <td class="paramname"><em>channelOrder</em> = <code><a class="el" href="classcinder_1_1_surface_channel_order.html#aaff3651ad59ef9ac3239a7ef7796f18ca5ab01894183ce51b9c6ef707828fdd4f">SurfaceChannelOrder::UNSPECIFIED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Surface object that is <em>height</em> and <em>width</em> pixels, an alpha channel based on <em>alpha</em>, and the channel order <em>channelOrder</em>. </p>
<p>As an example, the following would create a 640x480 pixel surface with an alpha channel, and an RGBA channel order <code>Surface32f mySurface( 640, 480, true, SurfaceChannelOrder::RGBA );</code> </p>

</div>
</div>
<a class="anchor" id="a7f8eb913b83effb58ee15badd198dcd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9004fd8b1e0c500e02fcdfbdbe571ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a>&#160;</td>
          <td class="paramname"><em>channelOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a surface from the memory pointed to by <em>data</em>. Does not assume ownership of the memory in <em>data</em>, which consequently should not be freed while the Surface is still in use. </p>

</div>
</div>
<a class="anchor" id="a55e994d9c8a799dd4a4540d6650f7ecb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecinder.html#aca11590d504e68de86f3a57444c2eb70">ImageSourceRef</a>&#160;</td>
          <td class="paramname"><em>imageSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classcinder_1_1_surface_constraints_default.html">SurfaceConstraintsDefault</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::tribool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>boost::logic::indeterminate</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Surface object from an <a class="el" href="classcinder_1_1_image_source.html">ImageSource</a>, for instance from the result of a <a class="el" href="namespacecinder.html#ad49aa427548e365f95336af782c2161a" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a> call. </p>
<p>To load an image from a resource, pass the result of the <a class="el" href="namespacecinder.html#ad49aa427548e365f95336af782c2161a" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a> call to the Surface constructor as shown below <code>Surface mySurface = Surface( loadImage( loadResource( RES ) );</code> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a79defcf8e73b0526f26af3be914f78be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::operator <a class="el" href="namespacecinder.html#aca11590d504e68de86f3a57444c2eb70">ImageSourceRef</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a32a1e5d14987a74b858969eb5ee81c42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::operator <a class="el" href="namespacecinder.html#aa5caf83179f34be27691363934b85afb">ImageTargetRef</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b8928d870737daf9f59fdfb83fa51e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the width of the Surface in pixels. </p>

</div>
</div>
<a class="anchor" id="abbb727cb106dc1b4b537991ccd1a218d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the height of the Surface in pixels. </p>

</div>
</div>
<a class="anchor" id="a240bf5253a4cfffa06a4ea6e07002331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the Surface in pixels. </p>

</div>
</div>
<a class="anchor" id="a24266e8d1474dc9f817183745c844791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getAspectRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Surface aspect ratio, which is its width / height. </p>

</div>
</div>
<a class="anchor" id="ab5c7c63efe35fc8c4c97531b4d20884e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_area.html">Area</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding <a class="el" href="classcinder_1_1_area.html">Area</a> of the Surface in pixels: [0,0]-(width,height) </p>

</div>
</div>
<a class="anchor" id="a82124f1cf056043b85248eacf472e225"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::hasAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the Surface contains an alpha channel. </p>

</div>
</div>
<a class="anchor" id="a73e75b813f8af6255e3de692086abdd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::isPremultiplied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the Surface color data is premultiplied by its alpha channel or not. </p>

</div>
</div>
<a class="anchor" id="af3cf7e047bb742b97186cfca3a131cb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setPremultiplied </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>premult</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the Surface color data should be interpreted as being premultiplied by its alpha channel or not. </p>

</div>
</div>
<a class="anchor" id="a81a5f9c0c1768c751f3096d1fe83ab11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getRowBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the width of a row of the Surface measured in bytes, which is not necessarily <a class="el" href="classcinder_1_1_surface_t.html#a1b8928d870737daf9f59fdfb83fa51e4" title="Returns the width of the Surface in pixels. ">getWidth()</a> * <a class="el" href="classcinder_1_1_surface_t.html#a550c975403a6f65c15348a6c87ac338b" title="Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels...">getPixelInc()</a> </p>

</div>
</div>
<a class="anchor" id="a550c975403a6f65c15348a6c87ac338b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getPixelInc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels, which is either 3 or 4. </p>

</div>
</div>
<a class="anchor" id="a29d86f9b1875c30ac38dfb6447245049"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyPixels</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new Surface which is a duplicate. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized. </p>

</div>
</div>
<a class="anchor" id="a1c2e20f388b53fb6868c5ba393f0ecfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyPixels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new Surface which is a duplicate of an <a class="el" href="classcinder_1_1_area.html">Area</a> <em>area</em>. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized. </p>

</div>
</div>
<a class="anchor" id="a87dd5a31c22eab567c6d6be938518cd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retuns the raw data of an image as a pointer to either uin8t_t values in the case of a Surface8u or floats in the case of a Surface32f. </p>

</div>
</div>
<a class="anchor" id="ab91cd98ff60c2a42f80c6e35fdbf9840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42de94fd28f7d2cd9466a3e5818cb97b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36448ec39df80e5479cbc19a9b39d10d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aecb65f9b84984d2401784d0eeb49a016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataRed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the red channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. </p>

</div>
</div>
<a class="anchor" id="a71c2e4bc4a0716733baa09cd71d98688"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataRed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af06838ab7980d61a3e38c7d81c70cb1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataGreen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the green channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. </p>

</div>
</div>
<a class="anchor" id="a6ca0ac9cef34420506c50b0a4721187e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataGreen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc96e9623b2cf02a2b6e271dd39de862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataBlue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the blue channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. </p>

</div>
</div>
<a class="anchor" id="a60614c57a4e35717999c322e562a8777"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataBlue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add41dcdc946d694e77a205a3f655d40d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataAlpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the alpha channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. Undefined for Surfaces without an alpha channel. </p>

</div>
</div>
<a class="anchor" id="ac40094fa0fa5d0448c41fbaabb67ba15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataAlpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1252ffdf7852caccfd03b23df157467"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setDeallocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a>(*)(<a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> *)&#160;</td>
          <td class="paramname"><em>aDeallocatorFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> *&#160;</td>
          <td class="paramname"><em>aDeallocatorRefcon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the deallocator, an optional callback which will fire upon the Surface::Obj's destruction. This is useful when a Surface is wrapping another API's image data structure whose lifetime is tied to the Surface's. </p>

</div>
</div>
<a class="anchor" id="af12c7558fadb5a922d1d086c884bd10c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a>&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the channel order of the Surface, the in-memory ordering of the channels of each pixel. </p>

</div>
</div>
<a class="anchor" id="a93e1f09b8d4d98fad12977d4fffb0cf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getRedOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 0. </p>

</div>
</div>
<a class="anchor" id="a2c390c3d39809c34fcbc653788d0b1e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getGreenOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 1. </p>

</div>
</div>
<a class="anchor" id="a95ef6f9eaf2d5ea76a850497842a21a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getBlueOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 2. </p>

</div>
</div>
<a class="anchor" id="a072f2b80c7aca558f6cdb0997c1797a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getAlphaOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 3. Returns <a class="el" href="classcinder_1_1_surface_channel_order.html#a9c1f57f5975fdae6bd51fa5f31ec4301ae72ecc43e9d7c20bfeb89665268eaa3c">SurfaceChannelOrder::INVALID</a> in the absence of an alpha channel. </p>

</div>
</div>
<a class="anchor" id="aaf07eae37706817ca0885d306b5cd0e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setChannelOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>aChannelOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the channel order of the Surface, the in-memory ordering of the channels of each pixel. Call does not modify any pixel data, but does modify its interpretation. </p>

</div>
</div>
<a class="anchor" id="ae9e3a626f08cc734005b91ad63eed1f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channelIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface. ">SurfaceChannelOrder</a>. </p>

</div>
</div>
<a class="anchor" id="aa7e5e6da1ae553cae5d1485c2e66237a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channelIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface. ">SurfaceChannelOrder</a>. </p>

</div>
</div>
<a class="anchor" id="ad18dfcdd556a475d3141cdba45602eec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelRed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the red Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a958b48daeefd05e0ff2c7c33e9c21aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelGreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the green Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="ae36bbf0e559edbca50c03e4d44790ae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelBlue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the blue Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a822adcec9d90e990d7a4d8d6b79d8485"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the alpha Channel of the Surface. </p>
<p>Undefined in the absence of an alpha channel. </p>

</div>
</div>
<a class="anchor" id="af91d2903ff37e2b85ccd8786c6483d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelRed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the red Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a64a64d6c6418df75127d5f585a9b9e2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelGreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the green Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a498f923a3235754d916b07ac3b9ca938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelBlue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the blue Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="ab432240ffbc3c0c5906e25d4ea96f674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the alpha Channel of the Surface. </p>
<p>Undefined in the absence of an alpha channel. </p>

</div>
</div>
<a class="anchor" id="a862e892ced2cea8d422683ab82915012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt;T&gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for getting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead. </p>

</div>
</div>
<a class="anchor" id="abeef32100150e5748551c074b433f6ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead. </p>

</div>
</div>
<a class="anchor" id="a65b0c7a1d4ef7e749ec068df95fd9b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead. </p>

</div>
</div>
<a class="anchor" id="a73dda39e47f015905cc43471e7e426d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_lee_8h.html#a86694cda6be30088d2edec302ff3c1d1">void</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>srcArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecinder.html#a856f2784df30e9b72860f0fa3ca059cb">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"><em>relativeOffset</em> = <code><a class="el" href="classcinder_1_1_vec2.html#ab746e54851a2dec15ba2d547909efe59">Vec2i::zero</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the <a class="el" href="classcinder_1_1_area.html">Area</a> <em>srcArea</em> of the Surface <em>srcSurface</em> to <em>this</em> Surface. The destination <a class="el" href="classcinder_1_1_area.html">Area</a> is <em>srcArea</em> offset by <em>relativeOffset</em>. </p>

</div>
</div>
<a class="anchor" id="a11c5d89e1bcdf1c0e70d36adc6bb6bc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::areaAverage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an averaged color for the <a class="el" href="classcinder_1_1_area.html">Area</a> defined by <em>area</em>. </p>

</div>
</div>
<a class="anchor" id="a2d33a9fdbb5242e13e27c0dfc7fe7c33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface. ">Iter</a> which iterates the entire Surface. </p>

</div>
</div>
<a class="anchor" id="a8ed96afb9b9a7deb59e48e694dc2d3b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface. ">Iter</a> which iterates the <a class="el" href="classcinder_1_1_area.html">Area</a> <em>area</em>. </p>

</div>
</div>
<a class="anchor" id="a9e3c36d49617eb6c833177e1dc940cce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the entire Surface. </p>

</div>
</div>
<a class="anchor" id="adf005ed5921c23587fcdc470a9fe063b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area.html">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the <a class="el" href="classcinder_1_1_area.html">Area</a> <em>area</em>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cinder/<a class="el" href="_surface_8h_source.html">Surface.h</a></li>
<li>src/cinder/<a class="el" href="_surface_8cpp.html">Surface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
