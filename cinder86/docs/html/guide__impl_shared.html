<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Cinder: Implicitly Shared Objects in Cinder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cinder_extra_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.libcinder.org"><img alt="Logo" src="logo.png"/></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cinder
   &#160;<span id="projectnumber">0.8.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Implicitly Shared Objects in Cinder </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>A common design feature throughout Cinder is the idea of implicitly shared objects. To look at how this works, let's consider the following bit of code: </p><div class="fragment"><div class="line">gl::Texture textureA, textureB;</div>
<div class="line">textureA = <a class="code" href="namespacecinder.html#ad49aa427548e365f95336af782c2161a">loadImage</a>( <span class="stringliteral">&quot;cinder_logo.png&quot;</span> ); <span class="comment">// create an OpenGL texture from an image file</span></div>
<div class="line">textureB = textureA;</div>
</div><!-- fragment --><p> In this instance, <em>textureB</em> becomes another handle to the same texture as <em>textureA</em>. Consider for a moment the alternative. If the assignment above were to create a clone of the texture, this would be an extremely expensive operation. We'd need to copy all of the pixels off of the GPU, allocate a new Texture, and then upload a copy of all of these pixels back to the GPU. That's rough. However, the way <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a> and other classes like it are designed, this assignment is instead very fast. Basically assignment says, "here's the OpenGL Texture I'm referring to. You refer to it too."<br />
 <br />
</p>
<p>This is especially convenient in a couple of scenarios. First, returning Cinder objects from functions: </p><div class="fragment"><div class="line">gl::Texture createCheckboardTexture()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacecinder.html#a7f62055e4cb811edb9868b32595a1d64">Surface</a> checkerboardSurface( 256, 256, <span class="keyword">false</span> );</div>
<div class="line">    ... algorithm to make <a class="code" href="_g_lee_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a> checkboard pattern ...</div>
<div class="line">    <span class="keywordflow">return</span> gl::Texture( checkerboardSurface );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">gl::Texture myCheckerboard = createCheckerboardTexture();</div>
</div><!-- fragment --><p> In the hypothetical example above, we have a function which returns a new OpenGL texture as its result. This is made efficient and easy because of implict sharing. <em>myCheckerboard</em> is made to refer to the same <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a> which was allocated and returned by the createCheckerboardTexture() function. The implictly shared object design allows you to write natural code like this without worrying about the performance or safety of returning a class as a result.<br />
 <br />
 A second common use case is creating STL containers like <code>std::vector&lt;&gt;</code> out of Cinder's core types: </p><div class="fragment"><div class="line">std::vector&lt;gl::Texture&gt; myTextures;</div>
<div class="line">myTextures.push_back( createCheckerboardTexture() );</div>
</div><!-- fragment --><p> This code allocates an STL vector of textures, and then appends to this vector the result of a call to our createCheckerboardTexture() function. Safe, fast &amp; easy. <br />
</p>
<h2>Leaks</h2>
<p>One of the most important advantages of the implicitly shared design is that it makes it nearly impossible to leak memory or other resources. This is because implicitly shared objects are able to sort out amongst themselves when a resource is no longer being used, and will free that resource as soon as nobody is interested in it anymore. Last one to leave turns out the lights. This is very similar to garbage collection, but is even more powerful for the fact that resources are freed immediately, and not at some undetermined future time. Consider this code: </p><div class="fragment"><div class="line">gl::Texture outside;                                    <span class="comment">// 1</span></div>
<div class="line">{                                                       <span class="comment">// 2</span></div>
<div class="line">    gl::Texture temp1 = createCheckerboardTexture();    <span class="comment">// 3</span></div>
<div class="line">    gl::Texture temp2 = createCheckerboardTexture();    <span class="comment">// 4</span></div>
<div class="line">    outside = temp1;                                    <span class="comment">// 5</span></div>
<div class="line">}                                                       <span class="comment">// 6</span></div>
</div><!-- fragment --><p> At line 3, <em>temp1</em> is allocated and assigned a new texture. At line 4, <em>temp2</em> is also allocated and assigned a different texture. At line 5, we assign <em>outside</em> to refer to the same texture as <em>temp1</em>. At line 6, both <em>temp1</em> and <em>temp2</em> go out of scope, and their destructors are called. No other gl::Texture refers to the texture allocated at line 4, so this OpenGL texture is destroyed automatically and immediately. However <em>outside</em> still exists, and still refers to the same texture <em>temp1</em> did, so when <em>temp1</em> is destructed, the texture it referred to is not destroyed. You can trust that Cinder's classes will clean up after themselves, making it very difficult to write the sorts of leaks or double-frees that keep C++ programmers awake at night. <br />
</p>
<h2>Nulls</h2>
<p>One useful feature of this design is that implicitly shared objects can be the equivalent of a null pointer, which is to say they can be empty. The default constructor will allocate an object in this null state: </p><div class="fragment"><div class="line"><a class="code" href="namespacecinder.html#a7f62055e4cb811edb9868b32595a1d64">Surface</a> mySurface; <span class="comment">// default-constructed to be null &amp; empty</span></div>
</div><!-- fragment --><p> We can test this in the same ways we might test a pointer or a boolean </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>( mySurface )</div>
<div class="line">   ... <span class="comment">// do something with my non-null Surface</span></div>
</div><!-- fragment --><p> <br />
</p>
<h2>Advanced: Implementation</h2>
<p>You don't need to understand how Cinder classes implement this implicit sharing to make use of it. If you're just getting started with C++, you can stop reading, trusting that Cinder is managing things behind the scenes for you. But for more advanced users it's a helpful thing to understand, especially if you intend to contribute code back to the Cinder community. Let's continue using the <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a> class as an example. If you open <a class="el" href="_texture_8h.html">gl/Texture.h</a> and look inside, you'll see that it contains a member class called Obj. This class actually contains the "guts" you might have expected to see inside gl::Texture itself - things like the width of the texture in pixels (<em>mWidth</em>), or the OpenGL texture ID (<em>mTextureID</em>). The only member variable gl::Texture itself contains is a std::shared_ptr to one of these Obj's, called <em>mObj</em>. Now take a look at how a function like <a class="el" href="classcinder_1_1gl_1_1_texture.html#acb5b7270690679e4c9339c408e7c19d8">gl::Texture::getId()</a> is implemented: </p><div class="fragment"><div class="line"><a class="code" href="gldx_8h.html#a68c4714e43d8e827d80759f9cb864f3c">GLuint</a> gl::Texture::getId()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> mObj-&gt;mTextureID;</div>
<div class="line">}</div>
</div><!-- fragment --><p> As you can see, the gl::Texture returns its Obj's <em>mTextureID</em>. You'll find this sort of pattern used throughout <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a>'s implementation. Now consider what an assignment does: </p><div class="fragment"><div class="line">gl::Texture textureA = textureB;</div>
</div><!-- fragment --><p> While we did not have to write it explicitly (because C++ implicitly generated our operator= and copy constructor for us), this is the equivalent of: </p><div class="fragment"><div class="line">textureA.mObj = textureB.mObj;</div>
</div><!-- fragment --><p> Because of the way that shared_ptr's work, both <em>textureA</em> and <em>textureB</em> point to the same Obj. The fact that this is implemented using a shared_ptr is an implementation detail - the same effect could be achieved with a different technique, but shared_ptr's are a proven, easy way to make this possible, and it's one we'd recommend if you're designing your own classes to behave similarly. <br />
</p>
<h2>Advanced: Precedents</h2>
<p>This implicitly shared object pattern is not something unique to Cinder. If you are interested to see examples of it in other C++ class libraries, you can read about <a href="http://doc.trolltech.com/4.3/shared.html">Qt's implementation here</a>, <a href="http://docs.wxwidgets.org/trunk/overview_refcount.html#overview_refcount_destruct">wxWidgets' here</a> or take a look at the design of OpenCV's <a href="http://opencv.willowgarage.com/documentation/cpp/memory_management.html">memory management</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
