<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Chapter 1: Basic Image Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>If you're like me, you prefer to learn by example, so let's jump right into looking at some code. We'll begin by walking through a sample included with the OpenCV CinderBlock, located at <em>blocks/opencv/samples/ocvBasic</em>. This sample loads an image as a resource, and then performs some basic image processing and displays the results. Let's examine the code in detail:<br />
</p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_cinder_open_c_v_8h.html">CinderOpenCV.h</a>&quot;</span></div>
</div><!-- fragment --><p> Here's the first interesting line. We're just including the OpenCV CinderBlock's header file. This file contains the glue between Cinder and OpenCV, and it in turn includes the relevant headers from OpenCV itself. Next let's look at the setup() method: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ocvBasicApp::setup()</div>
<div class="line">{</div>
<div class="line">    ci::Surface8u surface( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#ad49aa427548e365f95336af782c2161a">loadImage</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a93522b1858f745f7d9438d6d124ae11b">loadResource</a>( RES_IMAGE ) ) );</div>
<div class="line">    <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="legacy_8hpp.html#a80a8d47bc3495dc7e8a3b5f4c78fa8e6">input</a>( toOcv( surface ) );</div>
<div class="line">    <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="legacy_8hpp.html#ad2a91d797896d7d86e0c03dc705a4abc">output</a>;</div>
<div class="line">    <a class="code" href="namespacecv.html#ad7c87bbc46b97e7eafa71357916ab568">cv::medianBlur</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, output, 11 );</div>
<div class="line">    ...</div>
<div class="line">    mTexture = gl::Texture( fromOcv( output ) );</div>
<div class="line">}    </div>
</div><!-- fragment --><p> <br />
The first line should be familiar. We're just creating a <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a> by loading an image from a resource. Next, we dive right into some proper OpenCV code. We create two instances OpenCV's <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> class. This class is very similar to Cinder's <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">Surface</a>, and can be used to represent an image. More on this important class later. Notice the constructor parameter for <em>input</em> - the result of a call to toOcv() with the <em>surface</em> we loaded earlier. This is our first exposure to the CinderBlock layer. This function simply translates a Cinder class into a form that is usable directly with OpenCV - in this case a ci::Surface into something suitable to construct a <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> with. We'll get deeper into how the OpenCV CinderBlock works in a bit. The second portion of the line constructs an empy <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> called <em>output</em>.<br />
<br />
Next, we get into some actual image processing. In this case, we are using OpenCV's <a class="el" href="namespacecv.html#ad7c87bbc46b97e7eafa71357916ab568" title="smooths the image using median filter. ">medianBlur()</a> function, which smooths an image using a median filter. The first parameter is the source <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a>, <em>input</em> in our case. The second parameter is the <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> which will hold the result. OpenCV automatically creates a <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> which is of the appropriate size and depth, and in our case will put this result into <em>output</em>. The final parameter is how large a window is examined for computing the median of each pixel - we've selected a kernel size of <code>11</code>.<br />
<br />
The last line of setup() creates an OpenGL texture used later in <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1gl.html#a375f873fcf7056a2f0d00ecea7257b46">draw()</a>. It makes use of the CinderBlock's fromOcv() function, which behaves just like toOcv() does but in the other direction, converting OpenCV's data structures into Cinder's equivalents. Running the sample gives us a smoothed version of our input image, which is <a href="http://www.flickr.com/photos/stuckincustoms/4045813826/">a photograph by Trey Ratcliff</a>.<br />
<br />
</p><div class="image">
<img src="ch1_median.jpg" alt="ch1_median.jpg"/>
</div>
<p> <br />
<br />
Nice. So let's try tweaking this code a bit. Try changing the kernel size from <code>11</code> to something like say, <code>21</code>. Just make sure it's odd and bigger than <code>1</code>. How do I know that? Well, the OpenCV docs told me. Now's a good time to get familiar with what they look like - checkout the <a href="http://opencv.willowgarage.com/documentation/cpp/image_filtering.html#medianBlur">description of medianBlur()</a>. As you learn OpenCV, you'll want to familiarize yourself with these docs, but for now let's keep moving.<br />
<br />
</p><h2>Sobel</h2>
<p>Let's experiment with a different image processing operator. First, comment out the line in setup() which calls <a class="el" href="namespacecv.html#ad7c87bbc46b97e7eafa71357916ab568" title="smooths the image using median filter. ">cv::medianBlur()</a>, and replace it with a call to the Sobel edge detection operator: </p><div class="fragment"><div class="line"><span class="comment">//  cv::medianBlur( input, output, 11 );</span></div>
<div class="line"><a class="code" href="namespacecv.html#a40f37c24a6f7a36dfe7c8a22fa2f7b7f">cv::Sobel</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, output, CV_8U, 0, 1 ); </div>
</div><!-- fragment --><p> The first two parameters to <a class="el" href="namespacecv.html#a40f37c24a6f7a36dfe7c8a22fa2f7b7f" title="applies generalized Sobel operator to the image ">cv::Sobel</a> should be familiar - they're the same as <a class="el" href="namespacecv.html#ad7c87bbc46b97e7eafa71357916ab568" title="smooths the image using median filter. ">cv::medianBlur()</a>. The third parameter is a little different though. Instead of automatically deriving what kind of <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> the output should be from the input, <a class="el" href="namespacecv.html#a40f37c24a6f7a36dfe7c8a22fa2f7b7f" title="applies generalized Sobel operator to the image ">cv::Sobel()</a> wants us to tell it what kind of image we want. By passing <code>CV_8U</code> we have asked for an 8-bit unsigned image, which is normal for most image processing. If we wanted say, a floating point image, we could pass <code>CV_32F</code> instead. The fourth and fifth parameters, which are <em>xOrder</em> and <em>yOrder</em> respectively, allow us to select between horizontal and vertical edges. By passing <code>0</code> and <code>1</code>, we have selected the vertical edges. Run this, and you should see a result about like this:<br />
<br />
</p><div class="image">
<img src="ch1_sobel_vert.jpg" alt="ch1_sobel_vert.jpg"/>
</div>
<p> <br />
There are additional optional parameters to <a class="el" href="namespacecv.html#a40f37c24a6f7a36dfe7c8a22fa2f7b7f" title="applies generalized Sobel operator to the image ">cv::Sobel()</a>. Checkout its <a href="http://opencv.willowgarage.com/documentation/cpp/image_filtering.html#Sobel">documentation here</a>. How do the horizontal edges compare? Try swapping the <code>0</code> and <code>1</code>, or experiment with the kernel size parameter the docs mention.<br />
<br />
</p><h2>Threshold</h2>
<p>And now we'll experiment with a final image processing operator, <a href="http://opencv.willowgarage.com/documentation/cpp/miscellaneous_image_transformations.html#cv-threshold">cv::threshold()</a>. The first and second parameters are consistent with <a class="el" href="namespacecv.html#a40f37c24a6f7a36dfe7c8a22fa2f7b7f" title="applies generalized Sobel operator to the image ">cv::Sobel()</a> and <a class="el" href="namespacecv.html#ad7c87bbc46b97e7eafa71357916ab568" title="smooths the image using median filter. ">cv::medianBlur()</a> - just the input and output image represented as <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a>'s. The third parameter specifies what value defines <em>above</em> and <em>below</em>, and the fourth is the maximum value. Since we're working on 8-bit unsigned images, we'll pass <code>128</code> and <code>255</code> for these two values. </p><div class="fragment"><div class="line"><a class="code" href="namespacecv.html#abd93e7119f2b85135109ab4b1f4f9eaf">cv::threshold</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, output, 128, 255, CV_8U );</div>
</div><!-- fragment --><p> <br />
</p><div class="image">
<img src="ch1_threshold.jpg" alt="ch1_threshold.jpg"/>
</div>
<p> <br />
</p><h2>More on <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a></h2>
<p>The <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> class provides a representation of an image, much like Cinder's <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">Surface</a> or <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">Channel</a> classes. To determine the size of a <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a>, use code like this: </p><div class="fragment"><div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> myMat( ... );</div>
<div class="line"><a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a72f7349e12a6766075862ed953868abe">console</a>() &lt;&lt; <span class="stringliteral">&quot;myMat is &quot;</span> &lt;&lt; myMat.size().width &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; myMat.size().height &lt;&lt; <span class="stringliteral">&quot; pixels.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The design of <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> is also quite similar to <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a> or <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">ci::Channel</a> with respect to memory management. Like these Cinder classes, <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> maintains a reference count, automatically freeing the associated memory when the refence count drops to zero. Furthermore, assigning one <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> to another is fast, since no image data is copied - just pointers to image data. This means you're safe passing <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a>'s by value (again, just like <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a> or <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">ci::Channel</a>). </p><div class="fragment"><div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> matA( toOcv( <span class="stringliteral">&quot;C:\\imageA.png&quot;</span> ) );</div>
<div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> matB = matA; <span class="comment">// matB and matA both reference the same image</span></div>
<div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> matC( toOcv( <span class="stringliteral">&quot;C:\\imageC.png&quot;</span> ) );</div>
<div class="line">matC = matA; <span class="comment">// the image matC was constructed with gets freed automatically here</span></div>
</div><!-- fragment --><p>Also just like Cinder's equivalent classes, you can allocate a <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> which is empy - the equivalent of a null pointer. To test for null with <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface</a>, we write something about like </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#a7f62055e4cb811edb9868b32595a1d64">Surface</a> mySurface( ... );</div>
<div class="line"><span class="keywordflow">if</span>( mySurface )</div>
<div class="line">    ... <span class="keywordflow">do</span> something with non-null mySurface ...</div>
</div><!-- fragment --><p> To perform the equivalent null-test with <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a>, use code like this: </p><div class="fragment"><div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> myMat( ... );</div>
<div class="line"><span class="keywordflow">if</span>( myMat.data() )</div>
<div class="line">    ... <span class="keywordflow">do</span> something with non-null myMat ...</div>
</div><!-- fragment --><p> <br />
A key difference between <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> and <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">Surface</a> or <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">Channel</a> is that a <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> can contain an image of many different varieties. While say, Cinder's <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#ad8b046fa928d58861b60465ceda392c5">Surface8u</a> class always represents an RGB(A) 8-bit image, a <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> might represent a 32-bit floating point RGB image, or an 8-bit grayscale image, or perhaps a 16-bit YUV image. To determine what sort of data the <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> contains, use <a href="http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#cv-mat-type">cv::Mat::type()</a>. This will return a value we can compare against constants like <code>CV_8U3</code>, which implies an 8-bit unsigned, 3-color image (corresponding to a <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_surface_t.html">ci::Surface8u</a> with no alpha channel), or say, <code>CV_32F1</code>, which corresponds to a <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_channel_t.html">ci::Channel32f</a>. These constants take the form <code>CV_</code>&lt;bit-depth&gt;{<code>U</code> | <code>S</code> | <code>F</code> }&lt;number-of-channels&gt;, and are discussed in <a href="http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#datatype">detail here</a>. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>.type() == CV_8U3 )</div>
<div class="line">    ... <span class="keywordflow">do</span> something with <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a> 3 <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#a229b40a5c39344f935b57d464a76cc77">channel</a>, 8-bit <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#a4f252db605f5b9117603096756e79824">image</a> ...</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>.type() == CV_32F3 )</div>
<div class="line">    ... <span class="keywordflow">do</span> something with <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a> 3 channel, 32-bit <span class="keywordtype">float</span> <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#a4f252db605f5b9117603096756e79824">image</a> ...</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    ... fail gracefully ...</div>
</div><!-- fragment --><p> <br />
</p><h2>The OpenCV CinderBlock</h2>
<p>The OpenCV CinderBlock has been designed to offer a combination of performance, flexibility and convenience. Rather than imposing an additional API users must learn and which must be maintained as OpenCV itself evolves, the CinderBlock consists of essentially just two overloaded functions, ci::toOcv(), and ci::fromOcv(). Armed with these, you can easily exchange data structures between OpenCV and Cinder. We have seen both used in the example code above: </p><div class="fragment"><div class="line">ci::Surface8u surface( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#ad49aa427548e365f95336af782c2161a">loadImage</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a93522b1858f745f7d9438d6d124ae11b">loadResource</a>( RES_IMAGE ) ) );</div>
<div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="legacy_8hpp.html#a80a8d47bc3495dc7e8a3b5f4c78fa8e6">input</a>( toOcv( surface ) ), <a class="code" href="legacy_8hpp.html#ad2a91d797896d7d86e0c03dc705a4abc">output</a>;</div>
<div class="line">...</div>
<div class="line">mTexture = gl::Texture( fromOcv( output ) );</div>
</div><!-- fragment --><p> Note that the first two lines could be condensed into one: </p><div class="fragment"><div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="legacy_8hpp.html#a80a8d47bc3495dc7e8a3b5f4c78fa8e6">input</a>( toOcv( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#ad49aa427548e365f95336af782c2161a">loadImage</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1app.html#a93522b1858f745f7d9438d6d124ae11b">loadResource</a>( RES_IMAGE ) ) ) ), <a class="code" href="legacy_8hpp.html#ad2a91d797896d7d86e0c03dc705a4abc">output</a>;</div>
</div><!-- fragment --><p> Note also that we can pass the result of ci::fromOcv(cv::Mat) to functions like writeImage directly: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_image_io_8h.html">cinder/ImageIo.h</a>&quot;</span></div>
<div class="line"><a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder.html#ae77edb896e2f8e90bba70000725f3b6e">writeImage</a>( <span class="stringliteral">&quot;openCV_output.png&quot;</span>, fromOcv( output ) );</div>
</div><!-- fragment --><p> <br />
</p><h2>The OpenCV C++ API</h2>
<p>If you've worked with OpenCV in the past, particularly older versions, you may be familiar with its procedural API. In more recent releases, OpenCV has introduced an object-oriented C++ API which allows greater brevity and is type-safe. The OpenCV CinderBlock is based upon this more modern API. However if you are working with legacy code, or you simply prefer it, you can still call the procedural API, passing <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class. ">cv::Mat</a> instances in place of <code>IplImages</code> or <code>Arr*</code>. For example, the two calls below are equivalent: </p><div class="fragment"><div class="line"><a class="code" href="classcv_1_1_mat.html">cv::Mat</a> <a class="code" href="legacy_8hpp.html#a80a8d47bc3495dc7e8a3b5f4c78fa8e6">input</a>( ... ), <a class="code" href="legacy_8hpp.html#ad2a91d797896d7d86e0c03dc705a4abc">output</a>;</div>
<div class="line">cvLaplace( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, output, CV_8U ); <span class="comment">// call the C function</span></div>
<div class="line"><a class="code" href="namespacecv.html#af33f59c828ca700ad7507ed10725414b">cv::Laplacian</a>( <a class="codeRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/_g_lee_8h.html#ad3c78daa7d8673f71649d4840c641779">input</a>, output, CV_8U ); <span class="comment">// call the C++ function</span></div>
</div><!-- fragment --><p> A helpful introduction to the C++ API <a href="http://opencv.willowgarage.com/documentation/cpp/introduction.html">is available here</a>. <br />
 </p><h2>Exercises</h2>
<ol type="1">
<li>Experiment with combining these basic OpenCV operators. How does the order of operations affect things? What happens if you run a threshold operator on top of a Sobel operator? What about a Sobel operator on top of a threshold operator?<br />
</li>
<li>Try making one of the image processing parameters (like the value parameter for cv::Threshold) user-controllable using <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1params_1_1_interface_gl.html">params::InterfaceGl</a>. If you've never made use of this feature of Cinder, start with the sample in <em>cinder/samples/paramsBasic</em>.<br />
</li>
<li>Adapt this sample to work based on the real-time input of a webcam using <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1_capture.html">Capture</a>, or the frames of a QuickTime movie using <a class="elRef" doxygen="/Users/andrewfb/Code/cinder_0.8.6_mac/docs/doxygen/cinder.tag:../../../../docs/html/" href="../../../../docs/html/classcinder_1_1qtime_1_1_movie_surface.html">qtime::MovieSurface</a>. <br />
</li>
</ol>
</div></div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>